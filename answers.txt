1) Какой самый эффективный способ конкатенации строк?
 - strings.Builder. Поскольку строки в Go неизменяемы, и каждый раз, когда вы добавляете строку в существующую переменную,
    в памяти выделяется новая строка(происходит постоянное копирование и выделение памяти). Решением по-лучше было бы
    использование массивов или слайсов - закинуть туда строки и собрать в одну. strings.Builder является решением данной проблемы оперируя слайсом не строк, а байт
2) Что такое интерфейсы, как они применяются в Go?
 - Интерфейсы представляют собой набор методов, которые определяют поведение объекта. Чтобы имплементировать нужно реализовать набор методов указанный в интерфейсе
 - Интерфейсы в Go предоставляют абстракцию над типами и позволяют реализовывать полиморфизм. Они помогают при интеграции с существующим кодом, тестированием и разделением ответственности
 - Использование интерфейсов в Go способствует разработке гибкого, расширяемого и легко тестируемого кода. Они позволяют работать с абстракциями и обеспечивают четкое определение требований к объектам,
   что способствует лучшей структуре программы.
 3) Чем отличаются RWMutex от Mutex?
  - RWMutex обеспечивает более гибкую синхронизацию доступа к данным, позволяя параллельное чтение и блокируя доступ на запись, в отличии от Mutex - который блокирует и чтение и запись
 4) Чем отличаются буферизированные и не буферизированные каналы?
  - В небуфферизированом канале после поступления данных от горутины, горутина блокируется и ждёт пока другая горутина не получит эти данные, также и получающая горутина будет блокироваться, пока отправляющая горутина не вышлет значение в канал.
    Это обеспечивает синхронизацию между горутинами и гарантирует безопасность доступа к данным
  - Буферизированные каналы позволяют отправлять и принимать данные без необходимости мгновенной синхронизации.
    Такой канал канал имеет фиксированную емкость, которая определяет количество элементов, которые могут быть отправлены в канал до того, как другая горутина примет данные из него.
    При отправке значения в буферизированный канал, горутина продолжит свое выполнение, если буфер не заполнен, и блокируется только при полном заполнении буфера.
    Прием данных из буферизированного канала также может быть асинхронным, если буфер содержит данные.
    Если буфер пуст, то прием данных блокируется до тех пор, пока другая горутина не отправит данные в канал.
  5) Какой размер у структуры struct{}{}?
   - Размер структуры зависит от количества полей, но т.к. структура пустая - фактически её размер равен нулю.
     Такие структуры используются для используются там, где нет надобности передавать определённые данные, но надо что-то передать(например служат индикатором того, что горутина отработала и можно закрывать канал)
  6) Есть ли в Go перегрузка методов или операторов?
   - В Golang нет перегрузки методов и операторов т.к. это увеличивает сложность и читаемость кода. У каждого метода должно быть уникальное название.
  7) В какой последовательности будут выведены элементы map[int]int?
   - В случайной последовательности
  8) В чем разница make и new?
   - new -> инициализирует с дефолтным значением и возвращает указатель на данные
   - make -> Выделяет память для ссылочных типов данных ( slice , map , chan ), а также инициализирует их базовые структуры данных.
  9) Сколько существует способов задать переменную типа slice или map?
   - slice := []int{1,2,3}
   - var slice []int
   - slice := make([]int, 0, 1)
  10)
    - Первый print выведет 1 т.к. указатель на а = 1
    - Второй print выведет 1 т.к. в golang в функциях идёт передача по значению(в данном примере значение указателя меняется только локально, не меняя указатель в main)
  11)
    - Выдаст значения от 0 до 4
    - Получим дедлок т.к. передали wg не по указателю и горутина работает с локальной копией wg(wg.Done произошёл локально в горутине ине передался) wg.Wait в цикле будет ждать вечно
  12)
    - Выведет 0 т.к. n := 0, а инкриментируется в цикле локальная переменная для цикла n, а выводим за циклом
  13)
    - [100 2 3 4 5]
    - Слайс ссылочный тип, поэтому мы можем через обращение по индексу поменять внутреннее значение,
      но при append мы добавляем новый элемент к копии которую передали(ещё слайс при нехватки capacity может релоцироваться)
      поэтому переменная v содержит указатель уже на другой слайс. Добавление переменной в слайс произошло локально, слайс в функции main не был перезаписан
  14)
    - [b b a][a a]
    - Вывелся изменённый слайс, который изменился только локально и не был перезаписан(потому что передали копию слайса в анонимную функцию, значения по индексу у исходного слайса не изменились т.к. изначально capacity слайса бы 2, но мы добавилит элемент и слайс расширился и скопировал значение, переставая ссылаться на старый массив)
    - И вывелся слайс который определили в main неизменный